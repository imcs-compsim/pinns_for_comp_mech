name: Run all examples

on:
  pull_request:
    branches: [ main ]

# Global environment variables that might need adaption in the future
env:
  BACKEND: pytorch
  ENV_NAME: compsim_pinns
  ENV_FILE: env.yaml
  PYTHON_PACKAGE_MANAGER: conda

jobs:
  test-example:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
    steps:
      - uses: actions/checkout@v4
      
      - name: Install system dependencies for GMSH
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            libgl1 \
            libglu1-mesa \
            libsm6 \
            libxext6 \
            libxrender1 \
            libxcursor1 \
            libxft2 \
            libxinerama1
          sudo rm -rf /var/lib/apt/lists/*

      - name: Install Miniforge (no external action)
        shell: bash -l {0}
        run: |
          set -euo pipefail
          echo "Installing Miniforge/Mambaforge (self-hosted installer)..."

          # choose platform/arch to match available Miniforge builds
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then
            ARCH_TAG="x86_64"
          elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
            # mac runners report arm64, Linux aarch64
            ARCH_TAG="aarch64"
          else
            ARCH_TAG="$ARCH"
          fi

          # Map to Miniforge naming for macOS / linux
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            if [[ "$ARCH_TAG" == "aarch64" ]]; then
              FN="Miniforge3-MacOSX-arm64.sh"
            else
              FN="Miniforge3-MacOSX-x86_64.sh"
            fi
          else
            if [[ "$ARCH_TAG" == "aarch64" ]]; then
              FN="Miniforge3-Linux-aarch64.sh"
            else
              FN="Miniforge3-Linux-x86_64.sh"
            fi
          fi

          # Download installer from latest releases (conda-forge/miniforge)
          URL="https://github.com/conda-forge/miniforge/releases/latest/download/${FN}"
          echo "Downloading $URL"
          curl -fsSL -o /tmp/miniforge.sh "$URL"
          chmod +x /tmp/miniforge.sh

          # Define installation directory and export as env variable for later steps
          export MINIFORGE_INSTALL_DIR="${HOME}/miniforge"
          echo "MINIFORGE_INSTALL_DIR=${MINIFORGE_INSTALL_DIR}" >> "$GITHUB_ENV"
          echo "Set MINIFORGE_INSTALL_DIR=$MINIFORGE_INSTALL_DIR"

          # Install Miniforge silently
          /tmp/miniforge.sh -b -p "${MINIFORGE_INSTALL_DIR}"

          # Put miniforge on PATH
          export PATH="${MINIFORGE_INSTALL_DIR}/bin:${PATH}"
          echo "${MINIFORGE_INSTALL_DIR}/bin" >> "$GITHUB_PATH"
          echo "Added MINIFORGE_INSTALL_DIR/bin to the PATH: ${PATH}"
          hash -r

          # Verify installation
          echo "package manager version: $($PYTHON_PACKAGE_MANAGER --version)"
          echo "python in base: $(python --version)"

          # Configure conda defaults (optional)
          $PYTHON_PACKAGE_MANAGER config --set channel_priority strict
          $PYTHON_PACKAGE_MANAGER config --add channels conda-forge

          # Install mamba into base for fast solving
          $PYTHON_PACKAGE_MANAGER install -y -n base mamba -c conda-forge

          # Check whether the envionment file is available
          if [ ! -f "$ENV_FILE" ]; then
            echo "Environment file '$ENV_FILE' not found; failing."
            exit 1
          fi

          # Update an existing or create a new environment
          if $PYTHON_PACKAGE_MANAGER env list | grep -q "^[[:space:]]*${ENV_NAME}[[:space:]]"; then
            echo "Updating existing env '$ENV_NAME' from $ENV_FILE"
            mamba env update -n "$ENV_NAME" -f "$ENV_FILE" --prune
          else
            echo "Creating env '$ENV_NAME' from $ENV_FILE"
            mamba env create -n "$ENV_NAME" -f "$ENV_FILE"
          fi

          echo "--- package manager info ---"
          $PYTHON_PACKAGE_MANAGER info
          echo "--- conda list (env $ENV_NAME) ---"
          $PYTHON_PACKAGE_MANAGER list -n "$ENV_NAME"

      - name: Run example scripts (150-seconds timeout each)
        shell: bash -l {0}
        run: |
          set -uo pipefail

          TIME_LIMIT_SECONDS=150
          STATUS=0
          TIMEOUT_FILES=()

          TF_EXAMPLES=(
                      "examples/beams/Euler_beam_fixed_static.py"
                      "examples/beams/Euler_beam_simply_complex_static.py
                    )

          # Helper: check if file is in TF_EXAMPLES
          function in_list() {
            local val="$1"
            for item in "${TF_EXAMPLES[@]}"; do
              if [[ "$item" == "$val" ]]; then
                return 0
              fi
            done
            return 1
          }

          while IFS= read -r f; do
            echo "Running $f (timeout ${TIME_LIMIT_SECONDS}s)"

            # Select backend dynamically
            if in_list "$f"; then
              CURRENT_BACKEND="tensorflow.compat.v1"
            else
              CURRENT_BACKEND="$BACKEND"
            fi

            set +e
            DDE_BACKEND="$CURRENT_BACKEND" timeout --foreground "${TIME_LIMIT_SECONDS}s" \
              $PYTHON_PACKAGE_MANAGER run -n "$ENV_NAME" --no-capture-output python "$f"
            rc=$?
            set -e

            if [ $rc -eq 124 ]; then
              echo "::warning file=$f::Timed out after ${TIME_LIMIT_SECONDS}s; skipping."
              TIMEOUT_FILES+=("$f")
              continue
            elif [ $rc -ne 0 ]; then
              echo "::error file=$f::Exited with code $rc"
              STATUS=1
              # continue to try remaining examples
              continue
            fi

            echo "Finished $f"
          done < <(find examples -type f -name '*.py' | sort)

          exit $STATUS
