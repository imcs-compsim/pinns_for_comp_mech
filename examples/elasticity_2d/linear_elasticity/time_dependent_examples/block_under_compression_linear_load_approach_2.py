import deepxde as dde
import numpy as np
from pathlib import Path

import numpy as np
from deepxde import backend as bkd

'''
@author: tsahin

Simple block under compression test for a 2D block for elastodynamics under linear load in time direction => p = -pressure*t for t [0,1]).
In this example, we generate the geometry using 2D mesh, and space-time domain is generated by adding time as the third dimension. 

The followings must be taken into account:

- The order of BCs must be always first geometrical BCs (Dirichlet and Neumann BCs) and then initial conditions. The reason is that as follows: We apply the Neumann and Dirichlet BCs
on the geometry and we use [cond] argument to select the points lying on the boundary. If we apply first initial conditions, then [cond] argument is shifted as the number of points 
containing ICs. Therefore, we get an error when slicing operation is attempted to select the corresponding points to apply that specific geometrical BC.
Thus, the order of BCs must be always first geometrical BCs (Dirichlet and Neumann BCs) and then initial conditions!!!
- For OperatorBC on initial conditions, (lambda _, on_initial: on_initial) operation does not work, so initial BCs must be defined using a function.  
- Usually, we use n=1 as dummy parameter to used all points during training in GMSH models. Meaning that, we set num_domain=1 and num_boundary=1 in dde.data.PDE.
However, in dde.data.TimePDE, this would not be the case: we have set 
    * num_domain: 
        ** either to the total number of points in geometry (geom.random_points(1).shape[0])
        **  or to a number smaller than total number of points in geometry
    * num_boundary:
        ** only the total number of boundary points (geom.random_boundary_points(1).shape[0)]
Basically, num_domain and num_boundary can't be the dummy parameter "1" anymore.
'''

from utils.elasticity import elasticity_utils
from utils.elasticity.elasticity_utils import pde_mixed_plane_strain_time_dependent, get_tractions_mixed_2d_spacetime, problem_parameters
from utils.postprocess.elasticity_postprocessing import solutionFieldOnMeshToVtkSpaceTime
from utils.postprocess.save_normals_tangentials_to_vtk import export_normals_tangentials_to_vtk
from utils.geometry.geometry_utils import calculate_boundary_normals

from utils.geometry.custom_geometry import GmshGeometryElement
from utils.geometry.gmsh_models import Block_2D

length = 1
height = 1

gmsh_options = {"General.Terminal":1, "Mesh.Algorithm": 6}
block_2d = Block_2D(coord_left_corner=[0,0], coord_right_corner=[length,height], mesh_size=0.05, gmsh_options=gmsh_options)

gmsh_model = block_2d.generateGmshModel(visualize_mesh=False)

revert_curve_list = []
revert_normal_dir_list = [1,2,1,1]
geom = GmshGeometryElement(gmsh_model, dimension=2, revert_curve_list=revert_curve_list, revert_normal_dir_list=revert_normal_dir_list)

# This allows for visualization of boundary normals in Paraview
export_normals_tangentials_to_vtk(geom, save_folder_path=str(Path(__file__).parent.parent.parent.parent), file_name="square_boundary_normals")

t_min = 0
t_max = 1
# The applied pressure 
pressure = 0.1
nu,lame,shear,e_modul = problem_parameters()

#spaceDomain = dde.geometry.Rectangle([x_min, y_min], [x_max, y_max])
timeDomain = dde.geometry.TimeDomain(t_min, t_max)
spaceTimeDomain = dde.geometry.GeometryXTime(geom, timeDomain)

elasticity_utils.geom = geom
elasticity_utils.spacetime_domain = spaceTimeDomain
 
# Top surface
def boundary_top(x, on_boundary):
    return on_boundary and np.isclose(x[1],1)

# Front surface
def boundary_initial(x, on_boundary):
    time_dimension = x[2]
    return np.isclose(time_dimension,0)

# Neumann BC on top
def apply_pressure_y_top(x,y,X):
    Tx, Ty, Tn, Tt = get_tractions_mixed_2d_spacetime(x, y, X)
    _, cond = calculate_boundary_normals(X, spaceTimeDomain)
    
    t_loc = x[:, 2:3][cond] # time only for boundary points
    
    return Ty + pressure*t_loc

# Initial BC for velocity component x
def apply_velocity_in_x(x,y,X):
    du_x_t = dde.grad.jacobian(y, x, i=0, j=2)# i=0 represents u_x, j=2 is time
    x_loc = x[:,0:1]

    return du_x_t - pressure/e_modul*nu*(1+nu)*x_loc

# Initial BC for velocity component y
def apply_velocity_in_y(x,y,X):
    du_y_t = dde.grad.jacobian(y, x, i=1, j=2) # i=1 represents u_y, j=2 is time
    y_loc = x[:,1:2]
    return du_y_t + pressure/e_modul*(1-nu**2)*y_loc

# Initial BCs for velocities
ic_velocity_in_x = dde.icbc.OperatorBC(spaceTimeDomain, apply_velocity_in_x, boundary_initial)
ic_velocity_in_y = dde.icbc.OperatorBC(spaceTimeDomain, apply_velocity_in_y, boundary_initial)    
# for displacements
# ic_u_x = dde.icbc.IC(spaceTimeDomain, lambda _: 0, lambda _, on_initial: on_initial, component=0)
# ic_u_y = dde.icbc.IC(spaceTimeDomain, lambda _: 0, lambda _, on_initial: on_initial, component=1)

# Neumann BC
bc_pressure_y_top = dde.OperatorBC(spaceTimeDomain, apply_pressure_y_top, boundary_top)

bcs = [bc_pressure_y_top, ic_velocity_in_x, ic_velocity_in_y] #, ic_u_x, ic_u_y] 

# n_dummy = 1
data = dde.data.TimePDE(
    spaceTimeDomain,
    pde_mixed_plane_strain_time_dependent,
    bcs,
    num_domain=geom.random_points(1).shape[0],#spaceDomain.random_points(1).shape[0]
    num_boundary=geom.random_boundary_points(1).shape[0],#spaceDomain.random_boundary_points(1).shape[0]
    num_initial=100,
    num_test=None
)

def output_transform(x, y):
    u = y[:, 0:1]
    v = y[:, 1:2]
    sigma_xx =  y[:, 2:3]
    sigma_yy =  y[:, 3:4]
    sigma_xy =  y[:, 4:5]
    
    x_loc = x[:, 0:1] # coord x
    y_loc = x[:, 1:2] # coord y
    t_loc = x[:, 2:3] # time
    
    # define surfaces
    y_at_h = (height-y_loc)
    y_at_0 = (y_loc)
    x_at_l = (length-x_loc)
    x_at_0 = (x_loc)
    
    # define the surfaces where shear forces will be applied.
    sigma_xy_surfaces = (y_at_h)*(y_at_0)*(x_at_l)*(x_at_0)
    
    return bkd.concat([u*(x_at_0)*t_loc, # u_x is 0 at x=0 (Dirichlet BC) + u_x = 0 at t=0 (Initial BC) 
                      v*(y_at_0)*t_loc, # u_y is 0 at y=0 (Dirichlet BC) + u_y = 0 at t=0 (Initial BC) 
                      sigma_xx*(x_at_l), 
                      sigma_yy, 
                      sigma_xy*sigma_xy_surfaces
                      ], axis=1)

# 3 inputs, 5 outputs for 3D 
layer_size = [3] + [50] * 5 + [5]
activation = "tanh"
initializer = "Glorot uniform"
net = dde.maps.FNN(layer_size, activation, initializer)
net.apply_output_transform(output_transform)

model = dde.Model(data, net)
model.compile("adam", lr=0.001)
losshistory, train_state = model.train(epochs=1000, display_every=200)

model.compile("L-BFGS")
losshistory, train_state = model.train(display_every=200)

#########################################################################################################################################
#### POST-PROCESSING #####
#########################################################################################################################################

time_steps = 10
time_interval = [0, 1]

solutionFieldOnMeshToVtkSpaceTime(geom, 
                            model,
                            time_interval=time_interval,
                            time_steps=time_steps, 
                            save_folder_path=str(Path(__file__).parent.parent.parent.parent), 
                            file_name="2D_block_time_linear_load_2")